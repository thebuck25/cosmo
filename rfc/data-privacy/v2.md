---
title: "RFC: Advanced Data Privacy - Configurable response obfuscating v2"
author: Jens Neuse
---

# Problem

In organizations where data privacy is paramount,
it's often necessary to obfuscate certain fields in the response to allow developers to debug issues without exposing sensitive information,
or to export data through APIs for data science or analytics purposes,
all in compliance with data privacy regulations.

Furthermore, it's important that obfuscation policies are stable,
ensuring that the data is always obfuscated in the same way,
allowing developers to rely on the obfuscation behavior.

# Solution

We propose a new feature that allows to obfuscate fields in responses depending on the user's role or the environment.
The configuration should be done at the Router level as Subgraph developers should not be the single point of control for data privacy.
The security team should be able to define the rules for obfuscation and the Router should enforce them.

To achieve this, we propose to add a new configuration entry in the Router configuration file that allows to define obfuscation policies.
Each policy consists of:
1. An activation rule using expr-lang to determine when the policy applies
2. Target specification (either YAML-based or expression-based) to determine which fields the policy affects
3. Obfuscation logic to transform the field values

## Context Objects

For obfuscation policies to work, we need to define context objects that contain all the information necessary to evaluate the expressions:

### Response Field Context Object:

```json
{
  "fieldName": "email",
  "fieldType": "String",
  "parentType": "User",
  "value": "user@example.com",
  "valueDataType": "string"
}
```

### Request Context Object:

The "activate" expression has access to the request context object.
The response context object is defined here: https://cosmo-docs.wundergraph.com/router/configuration/template-expressions

## Configuration Structure

The data privacy configuration consists of:

1. **Transformers**: Reusable obfuscation logic defined using expr-lang
2. **Policies**: Rules for when and how to apply obfuscation
3. **Configuration Options**: Options to control behavior and validation

```yaml
data_privacy:
  obfuscation:
    # Configuration options
    options:
      undefined_field_behavior: "warn" # Options: "warn", "error", "ignore"
      validate_transformers: true # Validate transformer return types on startup
    
    # Reusable transformers
    transformers:
      - name: "email"
        expression: |
          repeat("*", len(split(value, "@")[0])) + "@" + split(value, "@")[1]
      - name: "default"
        expression: |
          valueDataType == "boolean" ? false : 
          valueDataType == "number" ? 0 : 
          repeat("*", len(value))
      - name: "isoDate"
        expression: |
          date(value, "2006-01-02 15:04:05").Year() + "-**-**"
    
    # Obfuscation policies
    policies:
      - name: "Data Scientist Obfuscation"
        # When this policy is active (evaluated once per request)
        activate: "'data-scientist' in request.auth.roles"
        
        # YAML-based targeting (preferred for readability)
        # Note: targets are evaluated first and take precedence over custom rules
        targets:
          - type: "User"
            fields: ["email"]
            transform: "email"
          - type: "User" 
            fields: ["phoneNumber"]
            transform: "default"
          - scalar_type: "ISODate"
            transform: "isoDate"
        
        # For complex conditions not easily expressed in YAML
        # Custom rule is only evaluated if no target rule matches
        custom: |
          # This expression is evaluated for each field
          # It can access the field context and apply custom logic
          typeName == "LogEntry" && fieldName == "ipAddress" ? 
            replace(value, "\\d+$", "0") : 
            value
      
      - name: "Developer Obfuscation"
        activate: "'developer' in request.auth.roles"
        # Note: Either use a default_transform OR custom, not both.
        # When default_transform is specified, custom rules will be ignored.
        default_transform: "default" # Applied to all fields not matched by targets
        targets:
          - type: "User"
            fields: ["email"]
            transform: "email"
      
      - name: "Always Active Policy"
        # A policy can be set to always be active without expression evaluation
        always_active: true
        targets:
          - scalar_type: "EmailAddress"
            transform: "email"
```

## Detailed Specifications

### Policy Activation

Policies can be activated in two ways:

1. Using an `activate` expression that evaluates to `true` or `false` for each request:
   ```yaml
   activate: "'data-scientist' in request.auth.roles"
   ```

2. Using `always_active: true` for policies that should always be applied without expression evaluation:
   ```yaml
   always_active: true
   ```

> **Note:** `activate` and `always_active` are mutually exclusive. If both are specified, `always_active` takes precedence and the `activate` expression is ignored.

### Target-Based Field Selection

The `targets` field provides a readable, YAML-based way to specify which fields should be obfuscated and how:

```yaml
targets:
  # Match specific fields on a specific type
  - type: "User"
    fields: ["email"]
    transform: "email"  # References a transformer by name
  
  # Match all fields of a specific type
  - type: "CreditCard"
    transform: "default"
  
  # Match all fields of a specific scalar type
  - scalar_type: "EmailAddress"
    transform: "email"
  
  # Exclude specific fields from obfuscation (see 'Field Exclusion' section below)
  - type: "Audit"
    fields: ["timestamp"]
    exclude: true
  
  # Match multiple fields of a specific type
  - type: "User"
    fields: ["address", "phoneNumber", "ssn"]
    transform: "default"
```

### Interface Type Handling

The system provides special handling for GraphQL interfaces. When a target in a policy specifies a GraphQL interface as the `type`, the target will match:

1. The interface itself
2. Any object type that implements the interface 
3. Any field defined on either the interface or its implementing types

For example, if you have an interface `Person` implemented by types `User` and `Employee`:

```graphql
interface Person {
  id: ID!
  name: String!
}

type User implements Person {
  id: ID!
  name: String!
  email: String
}

type Employee implements Person {
  id: ID!
  name: String!
  employeeId: String!
}
```

A target like this:

```yaml
targets:
  - type: "Person"
    fields: ["name"]
    transform: "default"
```

Will match and apply the transformer to:
- The `name` field on the `Person` interface
- The `name` field on the `User` type
- The `name` field on the `Employee` type

Similarly, a target that specifies the interface without specific fields:

```yaml
targets:
  - type: "Person"
    transform: "default"
```

Will match all fields defined on the interface (`id` and `name`) across all implementing types.

This behavior allows for more concise policies when working with interfaces, as you can define a single rule that applies to all implementations rather than creating separate rules for each type.

### Null Value Handling

When a field value is `null`, the transformer logic is never called for that field. Null values remain null in the response, regardless of any matching obfuscation policy. This behavior ensures that:

1. The data shape is preserved (null values stay null)
2. No unnecessary transformer evaluations are performed
3. No transformer needs to handle null values specially

For example, if a user has `email: null` in the database:

```yaml
targets:
  - type: "User"
    fields: ["email"]
    transform: "email"  # This transformer will not be called if email is null
```

The response will maintain `email: null` and not attempt to obfuscate it.

### Field Exclusion

The `exclude: true` option allows specific fields to be completely exempted from obfuscation:

```yaml
# Example of field exclusion
targets:
  - type: "User"
    fields: ["id"]
    exclude: true
  - scalar_type: "ID"
    exclude: true
```

When a field is excluded:
- It has the highest priority over all other rules
- No transformer will be applied to the field
- No default_transform will be applied
- No custom expression will be evaluated

This makes the `exclude` option useful for:
- Preserving critical identifiers needed for debugging
- Ensuring specific fields are always readable in logs
- Maintaining integrity of fields that should never be obfuscated for functional reasons

### Target Evaluation Order

The order of targets in the list is significant. Targets are evaluated from top to bottom, and the first matching target is applied. Once a match is found, no further targets are evaluated for that field.

```yaml
targets:
  # This rule will be evaluated first
  - type: "User"
    fields: ["id"]
    exclude: true
  
  # This rule will be evaluated second
  - type: "User"
    transform: "default"  # Will apply to all User fields except id
```

If these rules were in the reverse order, the `exclude` rule would never be applied because all User fields (including id) would match the first rule:

```yaml
targets:
  # All User fields (including id) will match this rule first
  - type: "User"
    transform: "default"
  
  # This rule will never be evaluated for User.id
  # because the previous rule already matched
  - type: "User" 
    fields: ["id"]
    exclude: true
```

#### Recommended Target Ordering

For optimal control, consider ordering targets as follows:

1. Field-specific exclusions first
2. Type-specific exclusions
3. Scalar-specific exclusions
4. Field-specific transformations
5. Type-specific transformations
6. Scalar-specific transformations

This ordering ensures that exceptions and specific cases are handled before more general rules are applied.

### Default Transform and Custom Rules

The root-level `default_transform` provides a fallback transformer for all fields not matched by specific targets:

```yaml
# Applied to all fields not matched by targets
default_transform: "default"
```

> **⚠️ IMPORTANT:** `default_transform` and `custom` are mutually exclusive options. When `default_transform` is specified in a policy, any `custom` rules in the same policy will be ignored. You must choose one approach or the other for handling fields not matched by explicit targets.

### Configuration Options

```yaml
options:
  # How to handle references to undefined field types in the schema
  # - "warn": Log a warning but continue (default)
  # - "error": Fail to start the router
  # - "ignore": Silently ignore undefined field types
  undefined_field_behavior: "warn"
  
  # Whether to validate transformer return types on startup
  validate_transformers: true
  
  # Whether to log when obfuscation is applied
  log_obfuscation: false
```

#### Understanding Undefined Fields

An "undefined field" occurs when a target in the obfuscation configuration references a type or field that doesn't exist in the actual GraphQL schema. For example:

1. If a target specifies `type: "User"` but the "User" type doesn't exist in the schema
2. If a target specifies `type: "User"` and `fields: ["email"]` but the User type in the schema doesn't have an "email" field
3. If a target specifies `scalar_type: "EmailAddress"` but there's no scalar type called "EmailAddress" in the schema

The `undefined_field_behavior` option determines how the Router handles these situations:
- `"warn"`: Log a warning during startup but proceed with initialization (default)
- `"error"`: Fail to start the Router, requiring configuration correction
- `"ignore"`: Silently ignore undefined field references with no warnings or errors

Choosing the appropriate setting depends on your deployment approach. In development environments, `"warn"` helps identify misconfiguration while still allowing testing. In production, `"error"` ensures configuration accuracy before deployment.

## Example Configuration Scenarios

### Basic Email Obfuscation

```yaml
data_privacy:
  obfuscation:
    transformers:
      - name: "email"
        expression: |
          repeat("*", len(split(value, "@")[0])) + "@" + split(value, "@")[1]
    
    policies:
      - name: "Basic Privacy"
        always_active: true  # Always active without expression evaluation
        targets:
          - scalar_type: "EmailAddress"
            transform: "email"
          - type: "User"
            fields: ["email"] 
            transform: "email"
```

### Role-Based Obfuscation

```yaml
data_privacy:
  obfuscation:
    transformers:
      - name: "email"
        expression: |
          repeat("*", len(split(value, "@")[0])) + "@" + split(value, "@")[1]
      - name: "default"
        expression: |
          valueDataType == "boolean" ? false : 
          valueDataType == "number" ? 0 : 
          repeat("*", len(value))
    
    policies:
      - name: "Data Scientist Obfuscation"
        activate: "'data-scientist' in request.auth.roles"
        targets:
          - type: "User"
            fields: ["email"]
            transform: "email"
          - type: "User"
            fields: ["phoneNumber"]
            transform: "default"
```

### Default and Custom Obfuscation

```yaml
data_privacy:
  obfuscation:
    transformers:
      - name: "default"
        expression: |
          valueDataType == "boolean" ? false : 
          valueDataType == "number" ? 0 : 
          repeat("*", len(value))
      - name: "stringDefault"
        expression: |
          # Handle quoted strings properly
          repeat("*", len(value))
    
    policies:
      - name: "Default Obfuscation"
        activate: "'debug' in request.query"
        # Applied to all fields except those with overrides in targets
        default_transform: "default"
        targets:
          - scalar_type: "ID"
            exclude: true  # Don't obfuscate IDs
```

## Special Handling for String Values

To properly handle string values that may contain quotes, the expression engine will:

1. Parse the actual value of the string (without surrounding quotes)
2. Apply the expression to the parsed value
3. Format the result back as a valid string

For example, given:
```json
{
  "fieldName": "email",
  "fieldType": "String",
  "parentType": "User",
  "value": "user@example.com",
  "valueDataType": "string"
}
```

And an expression like `repeat("*", len(split(value, "@")[0])) + "@" + split(value, "@")[1]`,
the result would be `"****@example.com"`.

Note that this processing only occurs for non-null values. If a field is null, it remains null in the response and the transformer expression is not evaluated at all.

## Performance Considerations

The implementation will optimize for performance:

1. The "activate" expression is evaluated only once per request
2. The matching logic for targets is optimized to reduce evaluations
3. The expression evaluations could be cached when possible to avoid redundant evaluations

# Implementation

1. The "activate" expression will be evaluated once per request and should have access to the request context object.

2. If the expression evaluates to true:
   - For each field in the response:
     - Skip processing entirely if the field value is null (null values remain null)
     - Match against the targets list first
     - If no match, evaluate the "custom" expression if present
   - If both targets and custom are defined, targets take precedence (a field matched by a target will not be processed by the custom rule)

3. The obfuscation will only be applied to leaf fields (scalar values).

4. During initialization:
   - If `validate_transformers` is true, all transformers will be validated to ensure they return the expected types
   - Field types referenced in transformers will be checked against the schema
   - Based on `undefined_field_behavior`, warnings will be emitted or errors will be raised

5. The field context for each evaluation will be properly sanitized to handle string values correctly.

6. We will implement this functionality in graphql-go-tools by adding a "leaf node resolver" interface which the Router can implement.

7. If there are no policies defined or no policies are activated, the interface will be a no-op, and the Router will not evaluate any expressions, ensuring minimal performance impact.

## Configuration Schema Changes

The following changes will be required in the Router's `config.schema.json` to support the data privacy features:

```json
{
  "properties": {
    "data_privacy": {
      "type": "object",
      "description": "Configuration for data privacy features",
      "properties": {
        "obfuscation": {
          "type": "object",
          "description": "Configuration for response field obfuscation",
          "properties": {
            "options": {
              "type": "object",
              "description": "Global options for obfuscation behavior",
              "properties": {
                "undefined_field_behavior": {
                  "type": "string",
                  "description": "How to handle references to types or fields that don't exist in the schema",
                  "enum": ["warn", "error", "ignore"],
                  "default": "warn"
                },
                "validate_transformers": {
                  "type": "boolean",
                  "description": "Whether to validate transformer return types on startup",
                  "default": true
                },
                "log_obfuscation": {
                  "type": "boolean",
                  "description": "Whether to log when fields are obfuscated",
                  "default": false
                }
              }
            },
            "transformers": {
              "type": "array",
              "description": "Reusable transformation expressions that can be referenced by policies",
              "items": {
                "type": "object",
                "required": ["name", "expression"],
                "properties": {
                  "name": {
                    "type": "string",
                    "description": "Unique name for the transformer"
                  },
                  "expression": {
                    "type": "string",
                    "description": "Expression to transform field values, using expr-lang syntax"
                  }
                }
              }
            },
            "policies": {
              "type": "array",
              "description": "Obfuscation policies that define when and how to obfuscate fields",
              "items": {
                "type": "object",
                "required": ["name"],
                "properties": {
                  "name": {
                    "type": "string",
                    "description": "Name of the policy"
                  },
                  "activate": {
                    "type": "string",
                    "description": "Expression that activates this policy when it evaluates to true"
                  },
                  "always_active": {
                    "type": "boolean",
                    "description": "When true, this policy is always active without evaluating an expression",
                    "default": false
                  },
                  "targets": {
                    "type": "array",
                    "description": "Specific field targeting rules",
                    "items": {
                      "type": "object",
                      "properties": {
                        "type": {
                          "type": "string",
                          "description": "GraphQL type name to match"
                        },
                        "fields": {
                          "type": "array",
                          "items": {
                            "type": "string"
                          },
                          "description": "Field names to match (if omitted, all fields of the type will match)"
                        },
                        "scalar_type": {
                          "type": "string",
                          "description": "Scalar type name to match"
                        },
                        "transform": {
                          "type": "string",
                          "description": "Name of a transformer to apply"
                        },
                        "exclude": {
                          "type": "boolean",
                          "description": "When true, excludes this field from any obfuscation",
                          "default": false
                        }
                      }
                    }
                  },
                  "default_transform": {
                    "type": "string",
                    "description": "Transformer to apply to all fields not matched by explicit targets"
                  },
                  "custom": {
                    "type": "string",
                    "description": "Custom expression for fields not matched by targets (mutually exclusive with default_transform)"
                  }
                },
                "oneOf": [
                  {
                    "required": ["activate"]
                  },
                  {
                    "required": ["always_active"]
                  }
                ]
              }
            }
          },
          "required": ["transformers", "policies"]
        }
      }
    }
  }
}
```

This schema addition defines:

1. The overall structure for the `data_privacy` section
2. The `obfuscation` subsection with all its components:
   - Options with their defaults
   - Transformers with name and expression
   - Policies with activation rules, targets, and custom expressions
3. Type validation to ensure either `activate` or `always_active` is specified
4. Required fields for various object types

The schema ensures consistency with the RFC and provides validation for configuration values, helping catch configuration errors early. 